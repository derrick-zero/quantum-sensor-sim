import { Sensor } from '../sensors/Sensor';
import { Vector3 } from '../core/Vector3';
import { Constants } from '../core/Constants';
import { Logger } from '../core/Logger';

/**
 * Utility class for calculating electric fields generated by sensors.
 */
export class ElectricField {
  /**
   * Calculates the electric field at a given point due to a single sensor using Coulomb's law.
   * @param sensor - The sensor generating the field.
   * @param point - The point in space at which to evaluate the field.
   * @returns The electric field vector at the specified point.
   * @throws If the evaluation point coincides with the sensorâ€™s position.
   */
  public static calculateFieldAtPoint(sensor: Sensor, point: Vector3): Vector3 {
    const k = Constants.COULOMB_CONSTANT;

    // Determine the vector from sensor to the point and its magnitude.
    const rVector = point.subtract(sensor.position);
    const distance = rVector.magnitude();

    if (distance === 0) {
      throw new Error(
        'Evaluation point cannot be the same as the sensor position.'
      );
    }

    // Calculate the field magnitude based on Coulomb's law.
    const fieldMagnitude = (k * sensor.charge) / (distance * distance);
    // The field is directed along the normalized rVector.
    const fieldDirection = rVector.normalize();

    return fieldDirection.multiplyScalar(fieldMagnitude);
  }

  /**
   * Calculates the net electric field at a given point due to an array of sensors.
   * @param sensors - The array of sensors generating the field.
   * @param point - The point in space for evaluation.
   * @returns The net electric field vector at the given point.
   */
  public static calculateNetField(sensors: Sensor[], point: Vector3): Vector3 {
    let netField = new Vector3();

    for (const sensor of sensors) {
      try {
        const field = ElectricField.calculateFieldAtPoint(sensor, point);
        netField = netField.add(field);
      } catch (error) {
        // Log a warning and skip this sensor if evaluation fails.
        Logger.warn(
          `Skipping sensor ${sensor.id} in field calculation: ${
            (error as Error).message
          }`,
          'ElectricField.calculateNetField'
        );
      }
    }

    return netField;
  }
}
